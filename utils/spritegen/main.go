package main

import (
	"flag"
	"fmt"
	"image"
	"image/png"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
)

type App struct {
	InputFile    string
	OutputFormat string
	OutputFile   string
}

func main() {
	// Create a new instance of the application
	app := App{}

	// Define and parse the command-line flag
	flag.StringVar(&app.InputFile, "image", "", "Input PNG image file")
	flag.StringVar(&app.OutputFormat, "format", "png", "Output format (gb, png)")
	flag.StringVar(&app.OutputFile, "output", "output", "Output file (directory if png)")
	flag.Parse()

	// Run the application
	app.Run()
}

func (a *App) Run() {
	if a.InputFile == "" {
		fmt.Println("Please provide an input image file using the -image flag")
		return
	}

	if a.OutputFile == "" {
		slog.Error("please provide an output file using the -output flag")
		return
	}

	switch a.OutputFormat {
	case "png":
		err := os.MkdirAll(a.OutputFile, 0755)
		if err != nil {
			slog.Error("failed to create output directory", "error", err)
			return
		}
	}

	// Open and decode the input image
	img, err := a.openImage(a.InputFile)
	if err != nil {
		fmt.Printf("Error opening image: %v\n", err)
		return
	}

	// Convert the image to Game Boy background format
	background := a.convertToGameBoyTiles(img)
	slog.Info("converted to gameboy tiles", "count", len(background))

	// This is more of a debugging
	if a.OutputFormat == "png" {
		for i, tile := range background {
			path := fmt.Sprintf("%s/%d.png", a.OutputFile, i)
			tile.SavePNG(path)
			slog.Info("saving tile to png", "index", i, "path", path)
		}
		slog.Info("saved tiles to png", "directory", a.OutputFile)
		return
	}

	if a.OutputFormat == "gb" {
		err = a.tilesToGB(background)
		if err != nil {
			slog.Error("failed to convert to gb", "error", err)
			return
		}
		return
	}

	slog.Error("unsupported output format", "format", a.OutputFormat)
}

func (a *App) openImage(filename string) (image.Image, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	img, err := png.Decode(file)
	if err != nil {
		return nil, err
	}

	return img, nil
}

func (a *App) convertToGameBoyTiles(img image.Image) []BackgroundTile {
	bounds := img.Bounds()
	width, height := bounds.Max.X, bounds.Max.Y

	// Calculate the number of full 8x8 tiles
	tilesX := width / 8
	tilesY := height / 8

	tiles := make([]BackgroundTile, 0, tilesX*tilesY)

	for tileY := 0; tileY < tilesY; tileY++ {
		for tileX := 0; tileX < tilesX; tileX++ {
			tile := NewBackgroundTile(img, tileX*8, tileY*8)
			tiles = append(tiles, tile)
		}
	}

	return tiles
}

func (a *App) spriteName() string {
	fName := filepath.Base(a.InputFile)
	if strings.Contains(fName, ".") {
		fName = fName[:strings.LastIndex(fName, ".")]
	}

	return strings.ToLower(fName)
}

func (a *App) tilesToGB(tiles []BackgroundTile) error {
	// Extract ext
	ext := filepath.Ext(a.OutputFile)
	if ext != "" {
		a.OutputFile = a.OutputFile[:len(a.OutputFile)-len(ext)]
	}

	cfile, err := os.Create(a.OutputFile + ".c")
	if err != nil {
		return err
	}

	hFile, err := os.Create(a.OutputFile + ".h")
	if err != nil {
		return err
	}
	defer hFile.Close()
	defer cfile.Close()

	tileBuf := make([]byte, 0)
	for _, tile := range tiles {
		tileBuf = append(tileBuf, tile.EncodeGB()...)
	}

	tilesName := a.spriteName() + "_tiles"

	cBuf := strings.Builder{}
	cBuf.WriteString(fmt.Sprintf("#include \"%s.h\"\n", filepath.Base(a.OutputFile)))
	cBuf.WriteString("/* Auto-generated by spritegen */\n\n")
	cBuf.WriteString(
		fmt.Sprintf("const uint8_t %s[] = {", tilesName))
	for i, b := range tileBuf {
		if i%8 == 0 {
			cBuf.WriteString("\n")
		}
		cBuf.WriteString(fmt.Sprintf("0x%02x, ", b))
	}
	cBuf.WriteString("\n};")

	_, err = cfile.Write([]byte(cBuf.String()))
	if err != nil {
		return err
	}

	hBuf := strings.Builder{}
	hBuf.WriteString("/* Auto-generated by spritegen */\n")
	hBuf.WriteString("#pragma once\n")
	hBuf.WriteString("#include <stdint.h>\n\n")
	hBuf.WriteString("extern const uint8_t \n")
	hBuf.WriteString(tilesName + "[]")
	hBuf.WriteString(";\n\n")

	hBuf.WriteString(fmt.Sprintf("#define %s_TILE_COUNT (%d)\n",
		strings.ToUpper(a.spriteName()),
		len(tiles)))

	// Don't support 8x16 tiles yet
	hBuf.WriteString(fmt.Sprintf("#define %s_TILE_SIZE (%d)\n",
		strings.ToUpper(a.spriteName()),
		8))

	hFile.Write([]byte(hBuf.String()))

	return nil
}
